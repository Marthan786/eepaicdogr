<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ICD-O Smart Code Finder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#f5f1e6;
      --fg:#222;
      --muted:#6b6b6b;
      --border:#d8cfc0;
      --card:#ffffff;
      --accent:#0b6cff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: Calibri, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height:1.4;
    }
    main{ max-width:920px; margin:0 auto; padding:36px 20px; }
    h1{ font-size:20px; margin:0 0 16px 0; font-weight:600; }
    .bar{ display:flex; gap:10px; align-items:center; margin: 6px 0 18px 0; }
    input[type="text"]{
      flex:1; min-height:44px; padding:10px 14px;
      border:1px solid var(--border); border-radius:12px; background:#fff; color:var(--fg);
      font-size:16px; outline:none;
    }
    input[type="text"]:focus{ box-shadow:0 0 0 3px rgba(11,108,255,.08); border-color:#b7ae9f; }
    button{
      padding:10px 16px; min-height:44px; border:1px solid var(--border); border-radius:12px;
      background:#fff; cursor:pointer; font-size:16px;
    }
    button.primary{ background:var(--accent); color:#fff; border-color:transparent; }
    .card{
      background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; margin-top:16px;
      box-shadow:0 1px 0 rgba(0,0,0,.02);
    }
    .row{ display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    .muted{ color:var(--muted); font-size:12px; }
    .code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .altlist{ display:grid; gap:8px; }
    .pill{
      display:inline-block; padding:6px 10px; border:1px solid var(--border); border-radius:999px; font-size:12px; color:#333; background:#fff;
    }
    .small{ font-size:13px; }
    .status{ font-size:13px; color:#333; }
    .err{ color:#a11; }
    .ok{ color:#076b00; }
    .split{ display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width:800px){ .row, .split{ grid-template-columns:1fr; } }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <main>
    <h1>ICD-O Smart Code Finder</h1>
    <div class="bar">
      <input id="query" type="text" placeholder="Type cancer + site in English or Greek (e.g., καρκίνωμα μαστού, breast adenocarcinoma)" />
      <button id="go" class="primary">Find code</button>
    </div>
    <div id="status" class="status muted">Ready.</div>

    <div class="card" id="resultCard" style="display:none">
      <div class="row">
        <div>
          <div class="muted">Topography</div>
          <div id="bestTopo" class="small"></div>
        </div>
        <div>
          <div class="muted">Morphology</div>
          <div id="bestMorph" class="small"></div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <div class="muted">ICD-O</div>
        <div id="finalCode" class="code" style="font-size:18px; font-weight:600;">—</div>
      </div>
    </div>

    <div class="split" id="alts" style="display:none; margin-top:8px;">
      <div class="card">
        <div class="muted">Other possible topography matches</div>
        <div id="altTopo" class="altlist"></div>
      </div>
      <div class="card">
        <div class="muted">Other possible morphology matches</div>
        <div id="altMorph" class="altlist"></div>
      </div>
    </div>
  </main>

  <script>
    // Config: lightweight translation endpoint
    const LT_ENDPOINT = "https://libretranslate.com/translate"; // swap if rate-limited/CORS-blocked
    const TIMEOUT_MS = 5000;

    const $ = s => document.querySelector(s);
    let topo = [], morph = [];

    // Minimal GR→EN fallback dictionary for when the API sulks
    const GR_EN = {
      "καρκίνος":"carcinoma","καρκίνωμα":"carcinoma","αδενοκαρκίνωμα":"adenocarcinoma","πλακώδες":"squamous",
      "μικροκυτταρικό":"small cell","μη μικροκυτταρικό":"non-small cell","μελάνωμα":"melanoma","λέμφωμα":"lymphoma",
      "μαστός":"breast","στήθος":"breast","πνεύμονας":"lung","ήπαρ":"liver","ήπατος":"liver",
      "παχύ έντερο":"colon","κόλον":"colon","παγκρέας":"pancreas","στομάχι":"stomach","θυρεοειδής":"thyroid",
      "προστάτης":"prostate","ωοθήκη":"ovary","μήτρα":"uterus","ενδομήτριο":"endometrium","τραχήλος":"cervix",
      "δέρμα":"skin","γλώσσα":"tongue","οισοφάγος":"esophagus","νεφρός":"kidney","ουροδόχος κύστη":"bladder"
    };

    function hasGreek(s){ return /[Α-Ωα-ω]/.test(s||""); }

    function timeout(promise, ms){
      return new Promise((resolve, reject)=>{
        const t=setTimeout(()=>reject(new Error("timeout")), ms);
        promise.then(v=>{clearTimeout(t); resolve(v);}, e=>{clearTimeout(t); reject(e);});
      });
    }

    async function translateToEnglish(text){
      if(!hasGreek(text)) return text;
      try{
        const res = await timeout(fetch(LT_ENDPOINT, {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ q:text, source:"auto", target:"en", format:"text" })
        }), TIMEOUT_MS);
        if(res.ok){
          const data = await res.json();
          if(data && data.translatedText) return data.translatedText;
        }
      }catch(_e){}
      // Fallback: rough dictionary substitution
      let out = text.toLowerCase();
      for(const [gr,en] of Object.entries(GR_EN)){
        const rx = new RegExp(`\\b${gr}\\b`, "g");
        out = out.replace(rx, en);
      }
      return out;
    }

    function norm(s){
      return String(s||"")
        .toLowerCase()
        .normalize("NFD").replace(/\p{Diacritic}/gu,"")
        .replace(/[^a-z0-9./\s-]/g," ")
        .replace(/\s+/g," ")
        .trim();
    }

    function tokens(s){
      return norm(s).split(/\s+/).filter(t=>t.length>1);
    }

    // Canonicalize common shorthands
    function canonToken(t){
      const map = {
        "ca":"carcinoma","ca.":"carcinoma","cancer":"carcinoma",
        "adenoca":"adenocarcinoma","adeno":"adenocarcinoma","adeno-ca":"adenocarcinoma",
        "scc":"squamous","nsclc":"non-small","nscl":"non-small","gbm":"glioblastoma"
      };
      return map[t] || t;
    }

    function scoreCandidate(name, code, qTokens){
      const nameT = tokens(name).map(canonToken);
      let score = 0;

      // Code tokens in query boost heavily
      for(const qt of qTokens){
        if(/^[cC]\d{2}(\.\d)?$/.test(qt) && name.toUpperCase().includes(qt.toUpperCase())) score += 8;
        if(/^\d{4}(?:\/\d)?$/.test(qt) && String(code).startsWith(qt.replace(/\/.*/,""))) score += 8;
      }

      // Token matches
      for(const qt of qTokens){
        const q = canonToken(qt);
        if(!q) continue;
        if(nameT.includes(q)) score += 3;
        else if(norm(name).includes(q)) score += 2;
      }

      // Phrase overlap bonus
      const nameStr = " " + norm(name) + " ";
      const queryStr = " " + qTokens.map(canonToken).join(" ") + " ";
      if(nameStr.includes(queryStr.trim())) score += 2;

      // Tie-breaker: slightly favor cleaner names
      score += Math.max(0, 1.2 - Math.log(1 + name.length)/5);

      return score;
    }

    function topN(list, n){ return list.sort((a,b)=>b._score - a._score).slice(0,n); }

    async function loadCSV(pathList){
      for(const p of pathList){
        try{
          const res = await fetch(p, {cache:"no-store"});
          if(!res.ok) continue;
          const text = await res.text();
          return new Promise(resolve => Papa.parse(text, {header:true, skipEmptyLines:true, complete:r=>resolve(r.data)}));
        }catch(_e){}
      }
      return [];
    }

    async function loadData(){
      $("#status").textContent = "Loading CSVs…";
      topo = await loadCSV(["data/icdo_topography.csv","docs/data/icdo_topography.csv"]);
      morph = await loadCSV(["data/icdo_morphology.csv","docs/data/icdo_morphology.csv"]);
      if(!topo.length || !morph.length){
        $("#status").innerHTML = `<span class="err">Couldn’t load CSVs. Ensure <code>docs/data/icdo_topography.csv</code> and <code>docs/data/icdo_morphology.csv</code> exist and are UTF-8.</span>`;
        return;
      }
      $("#status").innerHTML = `<span class="ok">CSVs loaded.</span>`;
    }

    function pickField(row, candidates){
      for(const k of candidates){
        if(k in row) return k;
      }
      return null;
    }

    function searchBest(query){
      const qTokens = tokens(query);
      if(!qTokens.length) return null;

      // Detect headers (supports exact names and a couple of fallbacks)
      const topoCodeKey = pickField(topo[0]||{}, ["topography_code","TopographyCode","code"]);
      const topoNameKey = pickField(topo[0]||{}, ["site_name","SiteName","name","site"]);
      const morphCodeKey = pickField(morph[0]||{}, ["morphology_code","MorphologyCode","code"]);
      const morphNameKey = pickField(morph[0]||{}, ["preferred_term","PreferredTerm","name","term"]);

      if(!topoCodeKey || !topoNameKey || !morphCodeKey || !morphNameKey) return null;

      const topoScored = topo.map(r=>{
        const name = String(r[topoNameKey]||"");
        const code = String(r[topoCodeKey]||"");
        return {...r, _name:name, _code:code, _score: scoreCandidate(name, code, qTokens)};
      }).filter(x=>x._name && x._code);

      const morphScored = morph.map(r=>{
        const name = String(r[morphNameKey]||"");
        const code = String(r[morphCodeKey]||"");
        return {...r, _name:name, _code:code, _score: scoreCandidate(name, code, qTokens)};
      }).filter(x=>x._name && x._code);

      const bestT = topN(topoScored, 1)[0];
      const bestM = topN(morphScored, 1)[0];
      const altT = topN(topoScored, 6);
      const altM = topN(morphScored, 6);

      return { bestT, bestM, altT, altM };
    }

    function renderAlternatives(list, mount, onPick){
      mount.innerHTML = "";
      list.forEach(r=>{
        const btn = document.createElement("button");
        btn.type="button";
        btn.className="pill";
        btn.textContent = `${r._code} — ${r._name}`;
        btn.title = `Score ${r._score.toFixed(2)}`;
        btn.addEventListener("click", ()=> onPick(r));
        mount.appendChild(btn);
      });
    }

    function composeCode(top, morph){
      // Use morphology code as-is (includes behavior like /2 or /3)
      return `${top._code} ${morph._code}`;
    }

    async function run(){
      const raw = $("#query").value.trim();
      if(!raw){ return; }
      $("#status").textContent = "Translating and matching…";

      const translated = await translateToEnglish(raw);
      const res = searchBest(translated);

      if(!res || !res.bestT || !res.bestM){
        $("#resultCard").style.display="none";
        $("#alts").style.display="none";
        $("#status").innerHTML = `<span class="err">No confident match found. Include both a site (e.g., lung) and a histology (e.g., adenocarcinoma).</span>`;
        return;
      }

      // show best
      $("#resultCard").style.display="";
      $("#alts").style.display="";
      $("#bestTopo").textContent = `${res.bestT._code} — ${res.bestT._name}`;
      $("#bestMorph").textContent = `${res.bestM._code} — ${res.bestM._name}`;
      $("#finalCode").textContent = composeCode(res.bestT, res.bestM);

      // alternatives with click-to-override
      renderAlternatives(res.altT, $("#altTopo"), (pick)=>{
        $("#bestTopo").textContent = `${pick._code} — ${pick._name}`;
        $("#finalCode").textContent = composeCode(pick, res.bestM);
      });
      renderAlternatives(res.altM, $("#altMorph"), (pick)=>{
        $("#bestMorph").textContent = `${pick._code} — ${pick._name}`;
        $("#finalCode").textContent = composeCode(res.bestT, pick);
      });

      $("#status").innerHTML = `<span class="ok">Matched.</span>`;
    }

    $("#go").addEventListener("click", run);
    $("#query").addEventListener("keydown", e=>{ if(e.key==="Enter"){ e.preventDefault(); run(); } });

    (async ()=>{ await loadData(); })();
  </script>
</body>
</html>
