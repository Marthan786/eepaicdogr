<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ICD-O Code Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --bg:#f5f1e6;       /* beige */
      --fg:#222222;       /* dark text */
      --muted:#6b6b6b;    /* secondary text */
      --accent:#0b6cff;   /* links, highlights */
      --card:#ffffff;     /* card background */
      --border:#d8cfc0;   /* soft border */
    }
    *{ box-sizing: border-box; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: Calibri, "Segoe UI", Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      line-height:1.4;
    }
    main{
      max-width:1100px;
      margin:0 auto;
      padding:24px;
      display:grid;
      gap:20px;
      grid-template-columns: 1fr;
    }
    .grid{ display:grid; gap:16px; grid-template-columns: repeat(12, 1fr); }
    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px;
      box-shadow: 0 1px 0 rgba(0,0,0,0.02);
    }
    .span-3{ grid-column: span 3; }
    .span-6{ grid-column: span 6; }
    .span-12{ grid-column: span 12; }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input[type="text"], select{
      width:100%;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:10px;
      background:#ffffff;
      color:var(--fg);
      outline:none;
      min-height:40px;
    }
    input[type="text"]:focus, select:focus{
      border-color:#b7ae9f;
      box-shadow: 0 0 0 3px rgba(11,108,255,0.08);
    }
    .row{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    .btns{ display:flex; gap:10px; align-items:center; }
    button{
      padding:10px 14px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#ffffff;
      color:var(--fg);
      cursor:pointer;
    }
    button:hover{ border-color:#bcb4a5; }
    #resultCode{ font-size:18px; font-weight:600; letter-spacing:0.3px; }
    #copied{ display:none; font-size:12px; color:var(--accent); }
    .hint{ font-size:12px; color:var(--muted); }
    a{ color:var(--accent); text-decoration:none; }
    a:hover{ text-decoration:underline; }
    @media (max-width: 900px){
      .span-3{ grid-column: span 12; }
      .span-6{ grid-column: span 12; }
      .row{ grid-template-columns: 1fr; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <main>
    <!-- Language switcher (no header) -->
    <div class="card span-3">
      <label id="lbl_lang">Language</label>
      <select id="lang">
        <option value="en">English</option>
        <option value="el">Ελληνικά</option>
      </select>
    </div>

    <form id="icdoForm" class="grid">
      <div class="card span-6">
        <label id="lbl_filter_topo" for="filter_topo">Search Topography</label>
        <input id="filter_topo" type="text" placeholder="Type to filter (e.g., breast, lung, C50)" />
        <div id="hint_filter_topo" class="hint">Enter selects top result. Escape clears.</div>
      </div>
      <div class="card span-6">
        <label id="lbl_filter_morph" for="filter_morph">Search Morphology</label>
        <input id="filter_morph" type="text" placeholder="Type to filter (e.g., adenocarcinoma, 8500)" />
        <div id="hint_filter_morph" class="hint">Enter selects top result. Escape clears.</div>
      </div>

      <div class="card span-6">
        <label id="lbl_topography" for="topography">Topography</label>
        <select id="topography"><option value="">— choose topography —</option></select>
      </div>
      <div class="card span-6">
        <label id="lbl_morphology" for="morphology">Morphology</label>
        <select id="morphology"><option value="">— choose morphology —</option></select>
      </div>

      <div class="card span-6">
        <div class="row">
          <div>
            <label id="lbl_behavior" for="behavior">Behavior</label>
            <select id="behavior"></select>
          </div>
          <div>
            <label id="lbl_grade" for="grade">Grade</label>
            <select id="grade"></select>
          </div>
        </div>
      </div>

      <div class="card span-6">
        <label id="lbl_laterality" for="laterality">Laterality</label>
        <select id="laterality"></select>
      </div>

      <div class="card span-12">
        <div class="row">
          <div>
            <label id="lbl_final">Final ICD-O Code</label>
            <div id="resultCode">— your code will appear here —</div>
          </div>
          <div>
            <label id="lbl_parts">Parts</label>
            <div id="partsLine" class="hint"></div>
          </div>
        </div>
        <div class="btns" style="margin-top:12px;">
          <button type="submit" id="btn_compose">Compose</button>
          <button type="button" id="copyBtn">Copy</button>
          <button type="button" id="resetBtn">Reset</button>
          <span id="copied">Copied</span>
        </div>
      </div>
    </form>
  </main>

  <script>
    const $ = s => document.querySelector(s);
    const opt = (v,t)=>{const o=document.createElement("option");o.value=v;o.textContent=t;return o;};

    // Language data
    const i18n = {
      en: {
        title: "ICD-O Code Builder",
        language: "Language",
        search_topo_label: "Search Topography",
        search_topo_ph: "Type to filter (e.g., breast, lung, C50)",
        search_morph_label: "Search Morphology",
        search_morph_ph: "Type to filter (e.g., adenocarcinoma, 8500)",
        hint_enter: "Enter selects top result. Escape clears.",
        topography_label: "Topography",
        morphology_label: "Morphology",
        behavior_label: "Behavior",
        grade_label: "Grade",
        laterality_label: "Laterality",
        final_label: "Final ICD-O Code",
        parts_label: "Parts",
        choose_topography: "— choose topography —",
        choose_morphology: "— choose morphology —",
        choose_behavior: "— choose behavior —",
        behaviors: {
          "": "— choose behavior —",
          "0": "0 — Benign",
          "1": "1 — Uncertain",
          "2": "2 — In situ",
          "3": "3 — Malignant, primary",
          "6": "6 — Malignant, metastatic",
          "9": "9 — Malignant, uncertain"
        },
        grades: [
          ["", "(none)"],
          ["1","1 — Well differentiated"],
          ["2","2 — Moderately differentiated"],
          ["3","3 — Poorly differentiated"],
          ["4","4 — Undifferentiated"]
        ],
        lateralities: ["","Right","Left","Bilateral","Not applicable"],
        btn_compose: "Compose",
        btn_copy: "Copy",
        btn_reset: "Reset",
        copied: "Copied",
        must_choose: "Choose Topography, Morphology and Behavior.",
        copy_failed: "Copy failed. Select and press Ctrl+C.",
        code_placeholder: "— your code will appear here —",
        parts_topo: "Topography",
        parts_morph: "Morphology",
        parts_grade: "grade",
        parts_lat: "Laterality"
      },
      el: {
        title: "ICD-O Δημιουργία Κωδικού",
        language: "Γλώσσα",
        search_topo_label: "Αναζήτηση Τοπογραφίας",
        search_topo_ph: "Πληκτρολογήστε (π.χ. breast, lung, C50)",
        search_morph_label: "Αναζήτηση Μορφολογίας",
        search_morph_ph: "Πληκτρολογήστε (π.χ. adenocarcinoma, 8500)",
        hint_enter: "Enter επιλέγει το πρώτο αποτέλεσμα. Escape καθαρίζει.",
        topography_label: "Τοπογραφία",
        morphology_label: "Μορφολογία",
        behavior_label: "Συμπεριφορά",
        grade_label: "Βαθμός",
        laterality_label: "Πλευρικότητα",
        final_label: "Τελικός κωδικός ICD-O",
        parts_label: "Συστατικά",
        choose_topography: "— επιλέξτε τοπογραφία —",
        choose_morphology: "— επιλέξτε μορφολογία —",
        choose_behavior: "— επιλέξτε συμπεριφορά —",
        behaviors: {
          "": "— επιλέξτε συμπεριφορά —",
          "0": "0 — Καλοήθης",
          "1": "1 — Απροσδιόριστη καλοήθης/κακοήθης",
          "2": "2 — Επί τόπου (in situ)",
          "3": "3 — Κακοήθης, πρωτοπαθής",
          "6": "6 — Κακοήθης, μεταστατικός",
          "9": "9 — Κακοήθης, αδιευκρίνιστη"
        },
        grades: [
          ["", "(κανένα)"],
          ["1","1 — Καλά διαφοροποιημένος"],
          ["2","2 — Μέτρια διαφοροποιημένος"],
          ["3","3 — Πτωχά διαφοροποιημένος"],
          ["4","4 — Αδιαφοροποίητος"]
        ],
        lateralities: ["","Δεξιά","Αριστερά","Αμφοτερόπλευρα","Μη εφαρμόσιμο"],
        btn_compose: "Σύνθεση",
        btn_copy: "Αντιγραφή",
        btn_reset: "Επαναφορά",
        copied: "Αντιγράφηκε",
        must_choose: "Επιλέξτε Τοπογραφία, Μορφολογία και Συμπεριφορά.",
        copy_failed: "Αποτυχία αντιγραφής. Επιλέξτε και πατήστε Ctrl+C.",
        code_placeholder: "— ο κωδικός θα εμφανιστεί εδώ —",
        parts_topo: "Τοπογραφία",
        parts_morph: "Μορφολογία",
        parts_grade: "βαθμός",
        parts_lat: "Πλευρικότητα"
      }
    };

    // Placeholders used inside filters (updated on language change)
    const placeholders = { topo:"", morph:"" };

    let topoAll=[], morphAll=[];
    function norm(x){return String(x||"").trim().replace(/\s+/g," ").replace(/[–—]/g,"-");}

    async function loadCSVAny(paths){
      for (const path of paths){
        try {
          const res = await fetch(path, { cache: "no-store" });
          if (!res.ok) continue;
          const text = await res.text();
          return new Promise(resolve =>
            Papa.parse(text, { header:false, skipEmptyLines:true, complete:r=>resolve(r.data) })
          );
        } catch {}
      }
      throw new Error("Fetch failed for: " + paths.join(", "));
    }

    function pickCol(headerRow, candidates){
      if(!headerRow) return -1;
      const L = headerRow.map(c=>String(c||"").trim().toLowerCase());
      for(const cand of candidates){
        for(let i=0;i<L.length;i++){
          if(L[i].includes(cand)) return i;
        }
      }
      return -1;
    }

    function splitCodeAndNameJoined(cell){
      const s = String(cell||"");
      const m = s.match(/^(C\d{2}(?:\.\d)?)\s*[-–—]?\s*(.+)$/i);
      if(m) return {code: m[1].toUpperCase(), name: norm(m[2])};
      return null;
    }

    function guessTopoCode(row){
      const rx = /C\d{2}(?:\.\d)?/i;
      for(const cell of row){
        const m = String(cell||"").match(rx);
        if(m) return m[0].toUpperCase();
      }
      return "";
    }

    function robustMorphFromRow(row){
      for(const cell of row){
        const s = String(cell||"");
        const m = s.match(/^(\d{4})(?:\/\d)?\s*[-–—]?\s*(.+)$/);
        if (m) return { code: m[1], name: norm(m[2]) };
      }
      const codeIdx = row.findIndex(c => /\b\d{4}\b/.test(String(c||"")));
      if (codeIdx < 0) return null;
      const code = String(row[codeIdx]).match(/\b(\d{4})\b/)[1];
      const hasLetters = s => /[A-Za-zΑ-Ωα-ω]/.test(s);

      const parts = [];
      for (let j = codeIdx + 1; j < row.length; j++){
        const s = norm(row[j]);
        if (!s) continue;
        if (/\b\d{4}(?:\/\d)?\b/.test(s)) continue;
        if (/^[0-9/.\-]+$/.test(s)) continue;
        if (!hasLetters(s)) continue;
        parts.push(s);
      }
      if (parts.length) return { code, name: norm(parts.join(" ")) };

      const leftParts = [];
      for (let j = codeIdx - 1; j >= 0; j--){
        const s = norm(row[j]);
        if (!s) continue;
        if (/\b\d{4}(?:\/\d)?\b/.test(s)) continue;
        if (/^[0-9/.\-]+$/.test(s)) continue;
        if (!hasLetters(s)) continue;
        leftParts.unshift(s);
      }
      if (leftParts.length) return { code, name: norm(leftParts.join(" ")) };

      let best = "";
      for (const cell of row){
        const s = norm(cell);
        if (!hasLetters(s)) continue;
        if (s.length > best.length) best = s;
      }
      return best ? { code, name: best } : null;
    }

    // Filters with language-aware placeholders
    function setupFilter(inputId, selectEl, all, placeholderKey){
      const input = $("#"+inputId);
      function rebuild(list){
        const prev = selectEl.value;
        selectEl.innerHTML="";
        selectEl.appendChild(opt("", placeholders[placeholderKey] || ""));
        list.forEach(x=> selectEl.appendChild(opt(x.code, `${x.code} — ${x.name || "(no name)"}`)));
        if ([...selectEl.options].some(o=>o.value===prev)) selectEl.value=prev;
      }
      function filter(q){
        const n=q.trim().toLowerCase();
        if(!n){rebuild(all); return;}
        const out=all.filter(x=>(x.code+" "+(x.name||"")).toLowerCase().includes(n));
        rebuild(out);
      }
      input.addEventListener("input",()=>filter(input.value));
      input.addEventListener("keydown",(e)=>{
        if(e.key==="Escape"){input.value=""; filter(""); e.preventDefault();}
        if(e.key==="Enter"){
          const first=[...selectEl.options].find((o,i)=>i>0&&o.value);
          if(first){selectEl.value=first.value; selectEl.dispatchEvent(new Event("change",{bubbles:true}));}
          e.preventDefault();
        }
      });
      // expose a trigger to rebuild on language change
      selectEl._rebuildForLang = ()=>rebuild(all);
      rebuild(all);
    }

    async function loadData(){
      // Topography
      const trows = await loadCSVAny([
        "data/icdo_topography.csv",
        "docs/data/icdo_topography.csv"
      ]);
      const th = trows[0] || [];
      const topoCodeIdx = pickCol(th, ["topography code","topo code","site code","code","icd-o","icdo","icd o"]);
      const topoNameIdx = pickCol(th, ["topography name","topo name","site name","site","name","description","label","term","preferred term","όνομα","ονομασία","όρος","προτιμώμενος όρος"]);

      topoAll = (trows.slice(1)).map(row=>{
        if(topoCodeIdx>=0 && topoNameIdx>=0 && topoCodeIdx!==topoNameIdx){
          const code = norm(row[topoCodeIdx]||"");
          const name = norm(row[topoNameIdx]||"");
          return code && name ? {code,name} : null;
        }
        for(const cell of row){
          const split = splitCodeAndNameJoined(cell);
          if(split) return split;
        }
        const codeGuess = guessTopoCode(row);
        if(!codeGuess) return null;
        let nameGuess = "";
        for(const cell of row){
          const s = String(cell||"").trim();
          if(!s) continue;
          if(/C\d{2}(?:\.\d)?/i.test(s)) continue;
          nameGuess = norm(s); break;
        }
        return nameGuess ? {code:codeGuess, name:nameGuess} : null;
      }).filter(Boolean);

      // Morphology
      const mrows = await loadCSVAny([
        "data/icdo_morphology.csv",
        "docs/data/icdo_morphology.csv"
      ]);
      const mh = mrows[0] || [];
      const morphCodeIdx = pickCol(mh, ["morphology code","morph code","code","icd-o","icdo","icd o","morph"]);
      const morphNameIdx = pickCol(mh, [
        "morphology name","morph name","name","description","label","term","preferred term",
        "histology","diagnosis","who","english","greek",
        "όνομα","ονομασία","όρος","προτιμώμενος όρος","ιστολογία","διάγνωση"
      ]);
      const looksLikeHeader = mh.some(h => /code|morph|name|term|histology|όνομα|ονομασία|όρος|ιστολογία|διάγνωση/i.test(String(h||"")));
      const mDataRows = looksLikeHeader ? mrows.slice(1) : mrows;

      morphAll = mDataRows.map(row=>{
        if (morphCodeIdx>=0 && morphNameIdx>=0 && morphCodeIdx!==morphNameIdx){
          const code = norm(row[morphCodeIdx]||"").match(/\b(\d{4})\b/)?.[1] || "";
          const name = norm(row[morphNameIdx]||"");
          return code && name ? {code, name} : (code ? {code, name:""} : null);
        }
        return robustMorphFromRow(row);
      }).filter(Boolean);

      const topoSel=$("#topography"), morphSel=$("#morphology");
      topoSel.innerHTML=""; morphSel.innerHTML="";
      topoSel.appendChild(opt("","")); // placeholder filled by language apply
      morphSel.appendChild(opt("",""));

      topoAll.forEach(t=> topoSel.appendChild(opt(t.code, `${t.code} — ${t.name}`)));
      morphAll.forEach(m=> morphSel.appendChild(opt(m.code, `${m.code} — ${m.name || "(no name found)"}`)));

      // Controls (built during language apply to get translated labels)
    }

    function buildBehaviorSelect(lang){
      const beh=$("#behavior");
      const cur = beh.value;
      beh.innerHTML="";
      const map = i18n[lang].behaviors;
      Object.keys(map).forEach(v=> beh.appendChild(opt(v, map[v])));
      if ([...beh.options].some(o=>o.value===cur)) beh.value=cur;
    }
    function buildGradeSelect(lang){
      const grd=$("#grade");
      const cur = grd.value;
      grd.innerHTML="";
      i18n[lang].grades.forEach(([v,t])=> grd.appendChild(opt(v,t)));
      if ([...grd.options].some(o=>o.value===cur)) grd.value=cur;
    }
    function buildLateralitySelect(lang){
      const lat=$("#laterality");
      const cur = lat.value;
      lat.innerHTML="";
      i18n[lang].lateralities.forEach(x=> lat.appendChild(opt(x, x||"(none)")));
      if ([...lat.options].some(o=>o.value===cur)) lat.value=cur;
    }

    function applyLang(lang){
      // Title
      document.title = i18n[lang].title;
      $("#lbl_lang").textContent = i18n[lang].language;

      // Labels
      $("#lbl_filter_topo").textContent = i18n[lang].search_topo_label;
      $("#filter_topo").placeholder = i18n[lang].search_topo_ph;
      $("#hint_filter_topo").textContent = i18n[lang].hint_enter;

      $("#lbl_filter_morph").textContent = i18n[lang].search_morph_label;
      $("#filter_morph").placeholder = i18n[lang].search_morph_ph;
      $("#hint_filter_morph").textContent = i18n[lang].hint_enter;

      $("#lbl_topography").textContent = i18n[lang].topography_label;
      $("#lbl_morphology").textContent = i18n[lang].morphology_label;
      $("#lbl_behavior").textContent = i18n[lang].behavior_label;
      $("#lbl_grade").textContent = i18n[lang].grade_label;
      $("#lbl_laterality").textContent = i18n[lang].laterality_label;
      $("#lbl_final").textContent = i18n[lang].final_label;
      $("#lbl_parts").textContent = i18n[lang].parts_label;

      // Buttons
      $("#btn_compose").textContent = i18n[lang].btn_compose;
      $("#copyBtn").textContent = i18n[lang].btn_copy;
      $("#resetBtn").textContent = i18n[lang].btn_reset;
      $("#copied").textContent = i18n[lang].copied;

      // Placeholders for selects
      placeholders.topo = i18n[lang].choose_topography;
      placeholders.morph = i18n[lang].choose_morphology;
      // refresh first option text for both selects
      const topoSel=$("#topography"), morphSel=$("#morphology");
      if (topoSel.options.length) topoSel.options[0].textContent = placeholders.topo;
      if (morphSel.options.length) morphSel.options[0].textContent = placeholders.morph;
      // trigger rebuild for filters so placeholder line refreshes
      topoSel._rebuildForLang && topoSel._rebuildForLang();
      morphSel._rebuildForLang && morphSel._rebuildForLang();

      // Rebuild translated selects
      buildBehaviorSelect(lang);
      buildGradeSelect(lang);
      buildLateralitySelect(lang);

      // Reset result placeholders to current language if empty
      if (!$("#resultCode").textContent.trim() || $("#resultCode").textContent.includes("will appear") || $("#resultCode").textContent.includes("εμφανιστεί")){
        $("#resultCode").textContent = i18n[lang].code_placeholder;
      }
    }

    function setupForm(){
      $("#icdoForm").addEventListener("submit",(e)=>{
        e.preventDefault();
        const lang = $("#lang").value || "en";
        const topo=$("#topography").value, morph=$("#morphology").value, beh=$("#behavior").value;
        const grade=$("#grade").value, lat=$("#laterality").value;
        if(!topo || !morph || !beh){ alert(i18n[lang].must_choose); return; }
        const morphFull = grade ? `${morph}/${beh}${grade}` : `${morph}/${beh}`;
        const latText = lat || "";
        const final = `${topo} ${morphFull}${latText? " — "+latText : ""}`;
        $("#resultCode").textContent = final;

        const topoText=$("#topography").selectedOptions[0]?.textContent||"";
        const morphText=$("#morphology").selectedOptions[0]?.textContent||"";
        const gradeBit = grade ? ` (${i18n[lang].parts_grade} ${grade})` : "";
        const latBit = latText ? ` | ${i18n[lang].parts_lat}: ${latText}` : "";
        $("#partsLine").textContent =
          `${i18n[lang].parts_topo}: ${topoText} | ${i18n[lang].parts_morph}: ${morphText} → ${morphFull}${gradeBit}${latBit}`;
      });

      $("#resetBtn").addEventListener("click",()=>{
        const lang = $("#lang").value || "en";
        $("#icdoForm").reset();
        $("#resultCode").textContent = i18n[lang].code_placeholder;
        $("#partsLine").textContent = "";
        // keep language select value
        $("#lang").value = lang;
      });

      $("#copyBtn").addEventListener("click", async ()=>{
        const lang = $("#lang").value || "en";
        const t=$("#resultCode").textContent.trim();
        if(!t || t===i18n[lang].code_placeholder) return;
        try{
          await navigator.clipboard.writeText(t);
          const ok=$("#copied"); ok.textContent=i18n[lang].copied; ok.style.display="inline";
          setTimeout(()=> ok.style.display="none",1200);
        }catch{ alert(i18n[lang].copy_failed); }
      });

      // Language change
      $("#lang").addEventListener("change", ()=>{
        const lang = $("#lang").value;
        localStorage.setItem("lang", lang);
        applyLang(lang);
      });
    }

    (async function(){
      if (typeof Papa === "undefined") {
        alert("PapaParse failed to load. Check the CDN script tag.");
        return;
      }
      // Initialize language preference
      const saved = localStorage.getItem("lang");
      const initialLang = saved ? saved : (navigator.language||"en").toLowerCase().startsWith("el") ? "el" : "en";
      $("#lang").value = initialLang;

      // Load data and set up filters
      await loadData();

      // Set up filters with language-aware placeholders
      setupFilter("filter_topo", $("#topography"), topoAll, "topo");
      setupFilter("filter_morph", $("#morphology"), morphAll, "morph");

      // Build form controls and apply language
      setupForm();
      applyLang(initialLang);
    })();
  </script>
</body>
</html>
