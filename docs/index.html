<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ICD-O Code Builder</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b0b0b; --fg:#f0f0f0; --muted:#9aa0a6; --accent:#6ee7ff; --card:#151515; --border:#2a2a2a; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:var(--bg); color:var(--fg); }
    header { padding:24px; border-bottom:1px solid var(--border); background:#0f0f0f; }
    header h1 { margin:0; font-size:20px; letter-spacing:0.2px; }
    main { max-width:1100px; margin:0 auto; padding:24px; display:grid; gap:20px; grid-template-columns: 1fr; }
    .grid { display:grid; gap:16px; grid-template-columns: repeat(12, 1fr); }
    .card { background:var(--card); border:1px solid var(--border); border-radius:14px; padding:16px; }
    .span-6 { grid-column: span 6; }
    .span-12 { grid-column: span 12; }
    label { display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    input[type="text"], select { width:100%; padding:10px 12px; border:1px solid var(--border); border-radius:10px; background:#0e0e0e; color:var(--fg); }
    select { min-height:40px; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    .btns { display:flex; gap:10px; align-items:center; }
    button { padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:#101010; color:var(--fg); cursor:pointer; }
    button:hover { border-color:#3a3a3a; }
    #resultCode { font-size:18px; font-weight:600; letter-spacing:0.3px; }
    #copied { display:none; font-size:12px; color:var(--accent); }
    .hint { font-size:12px; color:var(--muted); }
    .status { font-size:12px; color:var(--muted); }
    a { color:var(--accent); text-decoration:none; }
    a:hover { text-decoration:underline; }
    @media (max-width: 900px) {
      .span-6 { grid-column: span 12; }
      .row { grid-template-columns: 1fr; }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <header><h1>ICD-O Code Builder</h1></header>
  <main>
    <div class="card span-12 status">
      CSVs are loaded from <code>data/</code> or <code>docs/data/</code> automatically.
      If names don’t appear, your file likely lacks a name column. This page now also
      stitches multi-cell names and understands Greek headers.
    </div>

    <form id="icdoForm" class="grid">
      <div class="card span-6">
        <label for="filter_topo">Search Topography</label>
        <input id="filter_topo" type="text" placeholder="Type to filter (e.g., breast, lung, C50)" />
        <div class="hint">Enter selects top result. Escape clears.</div>
      </div>
      <div class="card span-6">
        <label for="filter_morph">Search Morphology</label>
        <input id="filter_morph" type="text" placeholder="Type to filter (e.g., adenocarcinoma, 8500)" />
        <div class="hint">Enter selects top result. Escape clears.</div>
      </div>

      <div class="card span-6">
        <label for="topography">Topography</label>
        <select id="topography"><option value="">— choose topography —</option></select>
      </div>
      <div class="card span-6">
        <label for="morphology">Morphology</label>
        <select id="morphology"><option value="">— choose morphology —</option></select>
      </div>

      <div class="card span-6">
        <div class="row">
          <div>
            <label for="behavior">Behavior</label>
            <select id="behavior"></select>
          </div>
          <div>
            <label for="grade">Grade</label>
            <select id="grade"></select>
          </div>
        </div>
      </div>

      <div class="card span-6">
        <label for="laterality">Laterality</label>
        <select id="laterality"></select>
      </div>

      <div class="card span-12">
        <div class="row">
          <div>
            <label>Final ICD-O Code</label>
            <div id="resultCode">— your code will appear here —</div>
          </div>
          <div>
            <label>Parts</label>
            <div id="partsLine" class="hint"></div>
          </div>
        </div>
        <div class="btns" style="margin-top:12px;">
          <button type="submit">Compose</button>
          <button type="button" id="copyBtn">Copy</button>
          <button type="button" id="resetBtn">Reset</button>
          <span id="copied">Copied</span>
        </div>
      </div>
    </form>

    <div class="card span-12 status" id="statusLine"></div>
  </main>

  <script>
    const $ = s => document.querySelector(s);
    const opt = (v,t)=>{const o=document.createElement("option");o.value=v;o.textContent=t;return o;};
    let topoAll=[], morphAll=[];

    function norm(x){return String(x||"").trim().replace(/\s+/g," ").replace(/[–—]/g,"-");}

    async function loadCSVAny(paths){
      for (const path of paths){
        try {
          const res = await fetch(path, { cache: "no-store" });
          if (!res.ok) continue;
          const text = await res.text();
          return new Promise(resolve =>
            Papa.parse(text, { header:false, skipEmptyLines:true, complete:r=>resolve(r.data) })
          );
        } catch {}
      }
      throw new Error("Fetch failed for: " + paths.join(", "));
    }

    function pickCol(headerRow, candidates){
      if(!headerRow) return -1;
      const L = headerRow.map(c=>String(c||"").trim().toLowerCase());
      for(const cand of candidates){
        for(let i=0;i<L.length;i++){
          if(L[i].includes(cand)) return i;
        }
      }
      return -1;
    }

    function splitCodeAndNameJoined(cell){
      const s = String(cell||"");
      const m = s.match(/^(C\d{2}(?:\.\d)?)\s*[-–—]?\s*(.+)$/i);
      if(m) return {code: m[1].toUpperCase(), name: norm(m[2])};
      return null;
    }

    function guessTopoCode(row){
      const rx = /C\d{2}(?:\.\d)?/i;
      for(const cell of row){
        const m = String(cell||"").match(rx);
        if(m) return m[0].toUpperCase();
      }
      return "";
    }

    // New: robust multi-cell morphology name extraction with Unicode letters (Greek-friendly)
// works in all browsers
function robustMorphFromRow(row){
  // 1) "8500/3 - Adenocarcinoma, NOS"
  for(const cell of row){
    const s = String(cell||"");
    const m = s.match(/^(\d{4})(?:\/\d)?\s*[-–—]?\s*(.+)$/);
    if (m) return { code: m[1], name: norm(m[2]) };
  }

  // 2) find first 4-digit code
  const codeIdx = row.findIndex(c => /\b\d{4}\b/.test(String(c||"")));
  if (codeIdx < 0) return null;
  const code = String(row[codeIdx]).match(/\b(\d{4})\b/)[1];

  // helper: is a plausible text token (has at least one letter A–Zα–ω)
  const hasLetters = s => /[A-Za-zΑ-Ωα-ω]/.test(s);

  // 3) collect text fragments AFTER code
  const parts = [];
  for (let j = codeIdx + 1; j < row.length; j++){
    const s = norm(row[j]);
    if (!s) continue;
    if (/\b\d{4}(?:\/\d)?\b/.test(s)) continue;
    if (/^[0-9/.\-]+$/.test(s)) continue;
    if (!hasLetters(s)) continue;
    parts.push(s);
  }
  if (parts.length){
    return { code, name: norm(parts.join(" ")) };
  }

  // 4) try BEFORE code
  const leftParts = [];
  for (let j = codeIdx - 1; j >= 0; j--){
    const s = norm(row[j]);
    if (!s) continue;
    if (/\b\d{4}(?:\/\d)?\b/.test(s)) continue;
    if (/^[0-9/.\-]+$/.test(s)) continue;
    if (!hasLetters(s)) continue;
    leftParts.unshift(s);
  }
  if (leftParts.length){
    return { code, name: norm(leftParts.join(" ")) };
  }

  // 5) pick longest textual cell
  let best = "";
  for (const cell of row){
    const s = norm(cell);
    if (!hasLetters(s)) continue;
    if (s.length > best.length) best = s;
  }
  return best ? { code, name: best } : null;
}

    function setupFilter(inputId, selectEl, all, placeholder){
      const input = $("#"+inputId);
      function rebuild(list){
        const prev = selectEl.value;
        selectEl.innerHTML="";
        selectEl.appendChild(opt("", placeholder));
        list.forEach(x=> selectEl.appendChild(opt(x.code, `${x.code} — ${x.name || "(no name)"}`)));
        if ([...selectEl.options].some(o=>o.value===prev)) selectEl.value=prev;
      }
      function filter(q){
        const n=q.trim().toLowerCase();
        if(!n){rebuild(all); return;}
        const out=all.filter(x=>(x.code+" "+(x.name||"")).toLowerCase().includes(n));
        rebuild(out);
      }
      input.addEventListener("input",()=>filter(input.value));
      input.addEventListener("keydown",(e)=>{
        if(e.key==="Escape"){input.value=""; filter(""); e.preventDefault();}
        if(e.key==="Enter"){
          const first=[...selectEl.options].find((o,i)=>i>0&&o.value);
          if(first){selectEl.value=first.value; selectEl.dispatchEvent(new Event("change",{bubbles:true}));}
          e.preventDefault();
        }
      });
      rebuild(all);
    }

    async function loadData(){
      const status = $("#statusLine");
      status.textContent = "Loading CSVs...";

      // ---- TOPOGRAPHY ----
      const trows = await loadCSVAny([
        "data/icdo_topography.csv",
        "docs/data/icdo_topography.csv"
      ]);

      const th = trows[0] || [];
      const topoCodeIdx = pickCol(th, ["topography code","topo code","site code","code","icd-o","icdo","icd o"]);
      const topoNameIdx = pickCol(th, ["topography name","topo name","site name","site","name","description","label","term","preferred term","όνομα","ονομασία","όρος","προτιμώμενος όρος"]);

      topoAll = (trows.slice(1)).map(row=>{
        if(topoCodeIdx>=0 && topoNameIdx>=0 && topoCodeIdx!==topoNameIdx){
          const code = norm(row[topoCodeIdx]||"");
          const name = norm(row[topoNameIdx]||"");
          return code && name ? {code,name} : null;
        }
        for(const cell of row){
          const split = splitCodeAndNameJoined(cell);
          if(split) return split;
        }
        const codeGuess = guessTopoCode(row);
        if(!codeGuess) return null;
        let nameGuess = "";
        for(const cell of row){
          const s = String(cell||"").trim();
          if(!s) continue;
          if(/C\d{2}(?:\.\d)?/i.test(s)) continue;
          nameGuess = norm(s); break;
        }
        return nameGuess ? {code:codeGuess, name:nameGuess} : null;
      }).filter(Boolean);

      // ---- MORPHOLOGY (very robust) ----
      const mrows = await loadCSVAny([
        "data/icdo_morphology.csv",
        "docs/data/icdo_morphology.csv"
      ]);

      const mh = mrows[0] || [];
      const morphCodeIdx = pickCol(mh, ["morphology code","morph code","code","icd-o","icdo","icd o","morph"]);
      const morphNameIdx = pickCol(mh, [
        "morphology name","morph name","name","description","label","term","preferred term",
        "histology","diagnosis","who","english","greek",
        "όνομα","ονομασία","όρος","προτιμώμενος όρος","ιστολογία","διάγνωση"
      ]);

      const looksLikeHeader = mh.some(h => /code|morph|name|term|histology|όνομα|ονομασία|όρος|ιστολογία|διάγνωση/i.test(String(h||"")));
      const mDataRows = looksLikeHeader ? mrows.slice(1) : mrows;

      morphAll = mDataRows.map(row=>{
        // Header-driven happy path
        if (morphCodeIdx>=0 && morphNameIdx>=0 && morphCodeIdx!==morphNameIdx){
          const code = norm(row[morphCodeIdx]||"").match(/\b(\d{4})\b/)?.[1] || "";
          const name = norm(row[morphNameIdx]||"");
          return code && name ? {code, name} : (code ? {code, name:""} : null);
        }
        // Heuristics across messy rows
        return robustMorphFromRow(row);
      }).filter(Boolean);

      const topoSel=$("#topography"), morphSel=$("#morphology");
      topoSel.innerHTML=""; morphSel.innerHTML="";
      topoSel.appendChild(opt("","— choose topography —"));
      morphSel.appendChild(opt("","— choose morphology —"));
      topoAll.forEach(t=> topoSel.appendChild(opt(t.code, `${t.code} — ${t.name}`)));
      morphAll.forEach(m=> morphSel.appendChild(opt(m.code, `${m.code} — ${m.name || "(no name found)"}`)));

      // Controls
      const beh=$("#behavior"); beh.innerHTML="";
      [
        {v:"",t:"— choose behavior —"},
        {v:"0",t:"0 — Benign"},
        {v:"1",t:"1 — Uncertain"},
        {v:"2",t:"2 — In situ"},
        {v:"3",t:"3 — Malignant, primary"},
        {v:"6",t:"6 — Malignant, metastatic"},
        {v:"9",t:"9 — Malignant, uncertain"}
      ].forEach(o=>beh.appendChild(opt(o.v,o.t)));

      const grd=$("#grade"); grd.innerHTML="";
      [
        {v:"",t:"(none)"},
        {v:"1",t:"1 — Well differentiated"},
        {v:"2",t:"2 — Moderately differentiated"},
        {v:"3",t:"3 — Poorly differentiated"},
        {v:"4",t:"4 — Undifferentiated"}
      ].forEach(o=>grd.appendChild(opt(o.v,o.t)));

      const lat=$("#laterality"); lat.innerHTML="";
      ["","Right","Left","Bilateral","Not applicable"].forEach(x=>lat.appendChild(opt(x, x||"(none)")));

      setupFilter("filter_topo", topoSel, topoAll, "— choose topography —");
      setupFilter("filter_morph", morphSel, morphAll, "— choose morphology —");

      const noNameCount = morphAll.filter(m => !m.name).length;
      status.textContent = `Loaded ${topoAll.length} topography entries and ${morphAll.length} morphology entries`
        + (noNameCount ? ` (${noNameCount} without names; likely missing name column).` : ".");
    }

    function setupForm(){
      $("#icdoForm").addEventListener("submit",(e)=>{
        e.preventDefault();
        const topo=$("#topography").value, morph=$("#morphology").value, beh=$("#behavior").value;
        const grade=$("#grade").value, lat=$("#laterality").value;
        if(!topo || !morph || !beh){ alert("Choose Topography, Morphology and Behavior."); return; }
        const morphFull = grade ? `${morph}/${beh}${grade}` : `${morph}/${beh}`;
        const final = `${topo} ${morphFull}${lat? " — "+lat : ""}`;
        $("#resultCode").textContent = final;

        const topoText=$("#topography").selectedOptions[0]?.textContent||"";
        const morphText=$("#morphology").selectedOptions[0]?.textContent||"";
        $("#partsLine").textContent = `Topography: ${topoText} | Morphology: ${morphText} → ${morphFull}${grade? " (grade "+grade+")":""}${lat? " | Laterality: "+lat:""}`;
      });

      $("#resetBtn").addEventListener("click",()=>{
        $("#icdoForm").reset();
        $("#resultCode").textContent="— your code will appear here —";
        $("#partsLine").textContent="";
      });

      $("#copyBtn").addEventListener("click", async ()=>{
        const t=$("#resultCode").textContent.trim();
        if(!t || t.includes("will")) return;
        try{
          await navigator.clipboard.writeText(t);
          const ok=$("#copied"); ok.style.display="inline";
          setTimeout(()=> ok.style.display="none",1200);
        }catch{ alert("Copy failed. Select and press Ctrl+C."); }
      });
    }

    (async function(){
      if (typeof Papa === "undefined") {
        alert("PapaParse failed to load. Check the CDN script tag.");
        return;
      }
      setupForm();
      try {
        await loadData();
      } catch (err) {
        console.error(err);
        $("#statusLine").textContent = "Failed to load CSVs. Ensure files exist, paths are correct, and CSVs are UTF-8.";
        alert("Failed to load CSVs from /data or /docs/data. Check console for details.");
      }
    })();
  </script>
</body>
</html>


